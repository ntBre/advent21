#+title: Advent of Code 2021

My solutions to the [[https://adventofcode.com/][Advent of Code]] puzzles for 2021.

* Day 1
  For part 1, just save the last element and check if the new one is
  greater than the last. If so, increment the count:

  #+begin_src lisp
    (defun count-increases (lst)
      (let ((last (car lst))
	    (count 0))
	(loop for l in lst
	      do (when (> l last)
		   (incf count))
		 (setf last l))
	count))
  #+end_src

  Since I initialize =last= to =(car lst)= I guess I should start the
  loop on =(cdr lst)= to save one iteration.

  For part 2, I reused the same =count-increases= function after doing
  one loop over the list and computing rolling sums of the last 3
  elements:

  #+begin_src lisp
    (defun three-buf (lst)
      (loop for i = 0 then (1+ i)
	    while (< i (- (length lst) 2))
	    collect (+ (elt lst i)
		       (elt lst (+ 1 i))
		       (elt lst (+ 2 i)))))
  #+end_src

  As usual, I had an off-by-one error in the first iteration where I
  subtracted 3 in the while portion instead of 2, but I caught it by
  comparing to the number of 3-element windows the example was
  supposed to have.

  It would be more efficient to combine these loops instead of doing
  them in two phases, but doing it this way let me reuse the
  =count-increases= function I already wrote (and tested) from the
  first part.

** Revision
   After seeing some of the solutions online, I rewrote my answer in a
   more functional form by using some zipping and filtering in
   =count-increases=.

   #+begin_src lisp
     (defun count-increases (lst)
       (length
	(remove-if-not
	 #'(lambda (x) (> (cadr x) (car x)))
	 (mapcar #'list lst (cdr lst)))))
   #+end_src

   For the second part, you can first "zip" the triples together with
   =+= and then use the results in =count-increases= much like in my
   original solution.

   #+begin_src lisp
     (defun part-2 ()
       (let ((input (load-input "input.txt")))
	 (count-increases
	  (mapcar #'+ input
		  (cdr input)
		  (cddr input)))))
   #+end_src

   Obviously this is quite similar to my original solution overall
   with the double loops, but now the two loops are implicitly
   contained in the =mapcar= calls instead of explicitly using =loop=.

* Day 2
  Today I just wrote everything at the top level of the file and it
  paid off smoothly. This is the solution to the second part, but the
  difference from the first part is only inside the =ecase= cases (and
  the addition of =a=, the aim) where I had to update the
  interpretation of the commands from the input.

  Today I learned that =ecase= does not work with string keys, which
  actually made it a bit easier since I could =mapcar= over the split
  line instead of only using =read-from-string= on the cadr of the
  line. Reading the strings from the string yields symbols with the
  same name so I can use symbols as the keys in the =ecase=. You also
  don't quote the symbols when using them as keys.

  #+begin_src lisp
    (let ((h 0)
	  (d 0)
	  (a 0))
      (with-open-file (in "input.txt" :direction :input)
	(loop for line = (read-line in nil nil)
	      while line
	      do (destructuring-bind (dir dist)
		     (mapcar #'read-from-string (uiop:split-string line))
		   (ecase dir
		     (forward
		      (incf h dist)
		      (incf d (* a dist)))
		     (down
		      (incf a dist))
		     (up
		      (decf a dist)))))
	(print (* h d))))
  #+end_src

* Day 3
  That was a tough one. Definitely a substantial increase in
  difficulty from the first two days I think. I'll have to try to come
  up with a better solution later, but at least I got it to work after
  about two hours. I think using arrays in Common Lisp was not a good
  idea. It's a real pain not being able to grab a row with something
  like =(aref arr 0)= if the array has more than one dimension. I
  probably should have stuck with lists in the second part like I did
  in the first part. Part 1 wasn't too bad:

  #+begin_src lisp
    (defun mask (counts)
      (map 'list #'(lambda (x)
		  (if (< x 0)
		      0
		      1))
	      counts))

    (defun to-bin (lst)
      (let ((ret 0)
	    (len (length lst)))
	(loop for i = 0 then (1+ i)
	      and l in lst
	      do (setf ret
		       (logior ret
			       (ash l (- len i 1)))))
	ret))

    (defun part1 ()
      (let* ((input (parse "inp.txt"))
	     (len (length (car input)))
	     (counts (make-array len)))
	(dolist (num input)
	  (loop for c across num
		and i = 0 then (1+ i)
		do (ecase c
		     (#\0
		      (decf (aref counts i)))
		     (#\1
		      (incf (aref counts i))))))
	;; count > 0 => 1; < 0 => 0
	(let* ((gam (to-bin (mask counts)))
	       ;; now it works for both example and input
	       (eps (logxor gam (ash #b111111111111
				     (- (length counts) 12)))))
	  (* gam eps))))
  #+end_src

  I just left the values as strings and looped across them, extracting
  individual chars. I incremented/decremented values in a result
  vector depending on whether the char is a 1 or 0, which lets me find
  the most common value in each position. I don't think I'm using
  "mask" correctly, but it converts a list of those counts such as =(2
  -2 4 2 -2)= to 1s and 0s like =(1 0 1 1 0)=. That's basically the
  answer for the gamma rate, so =to-bin= just converts that list to a
  binary number. I thought taking the complement of that would give
  the epsilon rate, but I think Common Lisp does two's complement
  instead one's complement like I wanted. As a result, I had to XOR
  the =to-bin= output with a bit vector of 1s.

  My Part 2 feels like a bit of a disaster because of all the array
  helper functions I had to write, but I guess the core logic isn't so
  bad.

  #+begin_src lisp
    (defun o2-rating (filename)
      (let ((inp (load-array (parse filename))))
	(loop while (> (nrows inp) 1)
	      for i from 0 below (ncols inp)
	      for col = (column inp i)
	      for mc = (most-common col)
	      do (setf inp (del-rows
			    #'(lambda (row) (/= (nth i row) mc))
			    inp)))
		 (to-bin (row inp 0))))
  #+end_src

  After loading the input as a bit array, I just loop over the columns
  (while there is more than one row left), find the =most-common=
  element in the column, and delete the rows where the most common
  element isn't found. Finally, convert the remaining row to a binary
  number just like before. Now that I think about it, this is a pretty
  clean translation of the problem logic into Lisp, but as you can see
  if you open the full code, the helper functions take up most of the
  space.
