#+title: Advent of Code 2021

My solutions to the [[https://adventofcode.com/][Advent of Code]] puzzles for 2021.

* Day 1
  For part 1, just save the last element and check if the new one is
  greater than the last. If so, increment the count:

  #+begin_src lisp
    (defun count-increases (lst)
      (let ((last (car lst))
	    (count 0))
	(loop for l in lst
	      do (when (> l last)
		   (incf count))
		 (setf last l))
	count))
  #+end_src

  Since I initialize =last= to =(car lst)= I guess I should start the
  loop on =(cdr lst)= to save one iteration.

  For part 2, I reused the same =count-increases= function after doing
  one loop over the list and computing rolling sums of the last 3
  elements:

  #+begin_src lisp
    (defun three-buf (lst)
      (loop for i = 0 then (1+ i)
	    while (< i (- (length lst) 2))
	    collect (+ (elt lst i)
		       (elt lst (+ 1 i))
		       (elt lst (+ 2 i)))))
  #+end_src

  As usual, I had an off-by-one error in the first iteration where I
  subtracted 3 in the while portion instead of 2, but I caught it by
  comparing to the number of 3-element windows the example was
  supposed to have.

  It would be more efficient to combine these loops instead of doing
  them in two phases, but doing it this way let me reuse the
  =count-increases= function I already wrote (and tested) from the
  first part.

** Revision
   After seeing some of the solutions online, I rewrote my answer in a
   more functional form by using some zipping and filtering in
   =count-increases=.

   #+begin_src lisp
     (defun count-increases (lst)
       (length
	(remove-if-not
	 #'(lambda (x) (> (cadr x) (car x)))
	 (mapcar #'list lst (cdr lst)))))
   #+end_src

   For the second part, you can first "zip" the triples together with
   =+= and then use the results in =count-increases= much like in my
   original solution.

   #+begin_src lisp
     (defun part-2 ()
       (let ((input (load-input "input.txt")))
	 (count-increases
	  (mapcar #'+ input
		  (cdr input)
		  (cddr input)))))
   #+end_src

   Obviously this is quite similar to my original solution overall
   with the double loops, but now the two loops are implicitly
   contained in the =mapcar= calls instead of explicitly using =loop=.

* Day 2
  Today I just wrote everything at the top level of the file and it
  paid off smoothly. This is the solution to the second part, but the
  difference from the first part is only inside the =ecase= cases (and
  the addition of =a=, the aim) where I had to update the
  interpretation of the commands from the input.

  Today I learned that =ecase= does not work with string keys, which
  actually made it a bit easier since I could =mapcar= over the split
  line instead of only using =read-from-string= on the cadr of the
  line. Reading the strings from the string yields symbols with the
  same name so I can use symbols as the keys in the =ecase=. You also
  don't quote the symbols when using them as keys.

  #+begin_src lisp
    (let ((h 0)
	  (d 0)
	  (a 0))
      (with-open-file (in "input.txt" :direction :input)
	(loop for line = (read-line in nil nil)
	      while line
	      do (destructuring-bind (dir dist)
		     (mapcar #'read-from-string (uiop:split-string line))
		   (ecase dir
		     (forward
		      (incf h dist)
		      (incf d (* a dist)))
		     (down
		      (incf a dist))
		     (up
		      (decf a dist)))))
	(print (* h d))))
  #+end_src
